{"mappings":"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","sources":["src/parcel/index.ts","src/lib/index.ts","src/lib/match-route.ts","src/web/router.ts"],"sourcesContent":["import lib from '../lib/index.js';\nimport matchRoute, { MatchRouteResult } from '../lib/match-route.js';\n\nimport Router from '../web/router.js';\n\nlib('PARCEL');\n\nlet lastHash: string | null = null;\n\nRouter.route = function (data: any, event?: PopStateEvent): any {\n\tconst hash = window.location.hash;\n\tif (lastHash === hash) {\n\t\treturn;\n\t}\n\n\t// NO HASH CHECK\n\tif (hash[0] !== '#') {\n\t\treturn void Router.replaceState(null, '#/');;\n\t}\n\n\t// BOOKMARK CHECK\n\tif (hash[1] !== '/') {\n\t\tif (lastHash === null) {\n\t\t\treturn void Router.pushState(null, '#/');\n\t\t}\n\t\treturn void Router.replaceState(null, lastHash, false);\n\t}\n\n\tlastHash = hash;\n\n\tlet match: MatchRouteResult = null;\n\tswitch (true) {\n\t\tcase !!(match = matchRoute('#/', hash)):\n\t\t\tconsole.group('HOME');\n\t\t\tconsole.log('MATCH', match);\n\t\t\tconsole.groupEnd();\n\t\t\tbreak;\n\n\t\tcase !!(match = matchRoute('#/page/**/:subpage/', hash) ?? matchRoute('#/page/', hash)):\n\t\t\tconsole.group('PAGE');\n\t\t\tconsole.log('MATCH', match);\n\t\t\tconsole.groupEnd();\n\t\t\tbreak;\n\n\t\tcase !!(match = matchRoute('#/redirect/', hash)):\n\t\t\tconsole.group('REDIRECT');\n\t\t\tconsole.log('MATCH', match);\n\t\t\tconsole.groupEnd();\n\t\t\tRouter.replaceState(null, '#/page/redirect/redirectpage/');\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.log('404');\n\t}\n}\n\nRouter.start();\n","export default function lib(message: string) {\n\tconsole.log(message);\n}\n\nlib('LIB');\n","export type MatchRouteResult = { data: Record<string, string>, query: string } | null;\n\nexport default function matchRoute(pattern: string, fullPath: string): MatchRouteResult {\n\tconst patternSegments = pattern.split('/');\n\n\tconst [path, query] = fullPath.split('?');\n\tconst pathSegments = path.split('/');\n\n\tconst match = matchSegments(patternSegments, pathSegments, false);\n\tif (match === null) {\n\t\treturn null;\n\t}\n\n\tconst { firstMatch } = match;\n\tif (firstMatch.index !== 0 || firstMatch.length !== pathSegments.length) {\n\t\treturn null;\n\t}\n\n\tconst { data } = firstMatch;\n\treturn { data, query };\n}\n\ninterface SegmentMatch {\n\tindex: number,\n\tlength: number,\n\tdata: Record<string, string>\n}\n\nfunction matchSegments(patternSegments: string[], pathSegments: string[], greedy = true): { firstMatch: SegmentMatch, lastMatch: SegmentMatch } | null {\n\tif (patternSegments.length === 0) {\n\t\tif (pathSegments.length === 0) {\n\t\t\treturn {\n\t\t\t\tfirstMatch: { index: 0, length: 0, data: {} },\n\t\t\t\tlastMatch: { index: 0, length: 0, data: {} },\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tconst patternSegment = patternSegments[0];\n\tconst remainingPatternSegments = patternSegments.slice(1);\n\n\tconst firstMatch: SegmentMatch = { index: -1, length: 0, data: {} };\n\tconst lastMatch: SegmentMatch = { index: -1, length: 0, data: {} };\n\n\tfor (let index = 0, length = pathSegments.length; index < length; index++) {\n\t\tconst pathSegment = pathSegments[index];\n\n\t\tif (patternSegment !== '**' && patternSegment !== '*' && patternSegment[0] !== ':' && patternSegment !== pathSegment) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (patternSegment === '**') {\n\t\t\tconst remainingPathSegments = pathSegments.slice(index);\n\t\t\tconst match = matchSegments(remainingPatternSegments, remainingPathSegments);\n\t\t\tif (match === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlastMatch.index = index;\n\t\t\tlastMatch.length = match.lastMatch.length + match.lastMatch.index;\n\t\t\tlastMatch.data = match.lastMatch.data;\n\n\t\t\tif (firstMatch.index === -1) {\n\t\t\t\tfirstMatch.index = index;\n\t\t\t\tfirstMatch.length = match.lastMatch.length + match.lastMatch.index;\n\t\t\t\tfirstMatch.data = match.lastMatch.data;\n\n\t\t\t\tif (!greedy) {\n\t\t\t\t\treturn { firstMatch, lastMatch };\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst remainingPathSegments = pathSegments.slice(index + 1);\n\t\tconst match = matchSegments(remainingPatternSegments, remainingPathSegments, false);\n\t\tif (match === null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (match.firstMatch.index !== 0) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst data: Record<string, string> = {};\n\t\tif (patternSegment[0] === ':') {\n\t\t\tconst key = patternSegment.slice(1);\n\t\t\tdata[key] = pathSegment;\n\t\t}\n\n\t\tlastMatch.index = index;\n\t\tlastMatch.length = match.firstMatch.length + 1;\n\t\tlastMatch.data = { ...data, ...match.firstMatch.data };\n\n\t\tif (firstMatch.index === -1) {\n\t\t\tfirstMatch.index = index;\n\t\t\tfirstMatch.length = match.firstMatch.length + 1;\n\t\t\tfirstMatch.data = { ...data, ...match.firstMatch.data };\n\n\t\t\tif (!greedy) {\n\t\t\t\treturn { firstMatch, lastMatch };\n\t\t\t}\n\t\t}\n\t}\n\n\tif (firstMatch.index === -1) {\n\t\treturn null;\n\t}\n\n\treturn { firstMatch, lastMatch };\n}\n","function eventHandler(event: PopStateEvent): any {\n\treturn Router.route(null, event);\n}\n\nlet hasStarted = false;\n\nconst Router = {\n\troute(data: any, event?: PopStateEvent): any {\n\t\tthrow new Error('route requires implementation');\n\t},\n\n\tstart(trigger = true) {\n\t\twindow.addEventListener('popstate', eventHandler);\n\t\thasStarted = true;\n\n\t\tif (trigger) {\n\t\t\tthis.route(null);\n\t\t}\n\t},\n\n\tpushState(data: any, url?: string | URL | null, trigger = true): void {\n\t\tif (!hasStarted) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.history.pushState(data, '', url);\n\n\t\tif (trigger) {\n\t\t\tthis.route(data);\n\t\t}\n\t},\n\n\treplaceState(data: any, url?: string | URL | null, trigger = true): void {\n\t\tif (!hasStarted) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.history.replaceState(data, '', url);\n\n\t\tif (trigger) {\n\t\t\tthis.route(data);\n\t\t}\n\t},\n\n\tstop() {\n\t\tif (!hasStarted) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.removeEventListener('popstate', eventHandler);\n\t\thasStarted = false;\n\t},\n};\n\nexport default Router;\n"],"names":[],"version":3,"file":"parcel.b4828738.js.map"}